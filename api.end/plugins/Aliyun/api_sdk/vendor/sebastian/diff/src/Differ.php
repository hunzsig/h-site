<?php
 namespace SebastianBergmann\Diff; use SebastianBergmann\Diff\LCS\LongestCommonSubsequence; use SebastianBergmann\Diff\LCS\TimeEfficientImplementation; use SebastianBergmann\Diff\LCS\MemoryEfficientImplementation; class Differ { private $header; private $showNonDiffLines; public function __construct($header = "--- Original\n+++ New\n", $showNonDiffLines = true) { $this->header = $header; $this->showNonDiffLines = $showNonDiffLines; } public function diff($from, $to, LongestCommonSubsequence $lcs = null) { $from = $this->validateDiffInput($from); $to = $this->validateDiffInput($to); $diff = $this->diffToArray($from, $to, $lcs); $old = $this->checkIfDiffInOld($diff); $start = isset($old[0]) ? $old[0] : 0; $end = \count($diff); if ($tmp = \array_search($end, $old)) { $end = $tmp; } return $this->getBuffer($diff, $old, $start, $end); } private function validateDiffInput($input) { if (!\is_array($input) && !\is_string($input)) { return (string) $input; } return $input; } private function checkIfDiffInOld(array $diff) { $inOld = false; $i = 0; $old = array(); foreach ($diff as $line) { if ($line[1] === 0 ) { if ($inOld === false) { $inOld = $i; } } elseif ($inOld !== false) { if (($i - $inOld) > 5) { $old[$inOld] = $i - 1; } $inOld = false; } ++$i; } return $old; } private function getBuffer(array $diff, array $old, $start, $end) { $buffer = $this->header; if (!isset($old[$start])) { $buffer = $this->getDiffBufferElementNew($diff, $buffer, $start); ++$start; } for ($i = $start; $i < $end; $i++) { if (isset($old[$i])) { $i = $old[$i]; $buffer = $this->getDiffBufferElementNew($diff, $buffer, $i); } else { $buffer = $this->getDiffBufferElement($diff, $buffer, $i); } } return $buffer; } private function getDiffBufferElement(array $diff, $buffer, $diffIndex) { if ($diff[$diffIndex][1] === 1 ) { $buffer .= '+' . $diff[$diffIndex][0] . "\n"; } elseif ($diff[$diffIndex][1] === 2 ) { $buffer .= '-' . $diff[$diffIndex][0] . "\n"; } elseif ($this->showNonDiffLines === true) { $buffer .= ' ' . $diff[$diffIndex][0] . "\n"; } return $buffer; } private function getDiffBufferElementNew(array $diff, $buffer, $diffIndex) { if ($this->showNonDiffLines === true) { $buffer .= "@@ @@\n"; } return $this->getDiffBufferElement($diff, $buffer, $diffIndex); } public function diffToArray($from, $to, LongestCommonSubsequence $lcs = null) { if (\is_string($from)) { $fromMatches = $this->getNewLineMatches($from); $from = $this->splitStringByLines($from); } elseif (\is_array($from)) { $fromMatches = array(); } else { throw new \InvalidArgumentException('"from" must be an array or string.'); } if (\is_string($to)) { $toMatches = $this->getNewLineMatches($to); $to = $this->splitStringByLines($to); } elseif (\is_array($to)) { $toMatches = array(); } else { throw new \InvalidArgumentException('"to" must be an array or string.'); } list($from, $to, $start, $end) = self::getArrayDiffParted($from, $to); if ($lcs === null) { $lcs = $this->selectLcsImplementation($from, $to); } $common = $lcs->calculate(\array_values($from), \array_values($to)); $diff = array(); if ($this->detectUnmatchedLineEndings($fromMatches, $toMatches)) { $diff[] = array( '#Warning: Strings contain different line endings!', 0 ); } foreach ($start as $token) { $diff[] = array($token, 0 ); } \reset($from); \reset($to); foreach ($common as $token) { while (($fromToken = \reset($from)) !== $token) { $diff[] = array(\array_shift($from), 2 ); } while (($toToken = \reset($to)) !== $token) { $diff[] = array(\array_shift($to), 1 ); } $diff[] = array($token, 0 ); \array_shift($from); \array_shift($to); } while (($token = \array_shift($from)) !== null) { $diff[] = array($token, 2 ); } while (($token = \array_shift($to)) !== null) { $diff[] = array($token, 1 ); } foreach ($end as $token) { $diff[] = array($token, 0 ); } return $diff; } private function getNewLineMatches($string) { \preg_match_all('(\r\n|\r|\n)', $string, $stringMatches); return $stringMatches; } private function splitStringByLines($input) { return \preg_split('(\r\n|\r|\n)', $input); } private function selectLcsImplementation(array $from, array $to) { $memoryLimit = 100 * 1024 * 1024; if ($this->calculateEstimatedFootprint($from, $to) > $memoryLimit) { return new MemoryEfficientImplementation; } return new TimeEfficientImplementation; } private function calculateEstimatedFootprint(array $from, array $to) { $itemSize = PHP_INT_SIZE === 4 ? 76 : 144; return $itemSize * \pow(\min(\count($from), \count($to)), 2); } private function detectUnmatchedLineEndings(array $fromMatches, array $toMatches) { return isset($fromMatches[0], $toMatches[0]) && \count($fromMatches[0]) === \count($toMatches[0]) && $fromMatches[0] !== $toMatches[0]; } private static function getArrayDiffParted(array &$from, array &$to) { $start = array(); $end = array(); \reset($to); foreach ($from as $k => $v) { $toK = \key($to); if ($toK === $k && $v === $to[$k]) { $start[$k] = $v; unset($from[$k], $to[$k]); } else { break; } } \end($from); \end($to); do { $fromK = \key($from); $toK = \key($to); if (null === $fromK || null === $toK || \current($from) !== \current($to)) { break; } \prev($from); \prev($to); $end = array($fromK => $from[$fromK]) + $end; unset($from[$fromK], $to[$toK]); } while (true); return array($from, $to, $start, $end); } } 